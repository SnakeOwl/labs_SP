все компилирует строкой: 
g++ -std=c++17 main.cpp -o program -lstdc++fs -pthread

lab_1: написать скрипт поиска файлов заданного размера в заданном каталоге (имя каталога задаётся пользователем в качестве третьего аргумента командной строки). Диапазон (мин.- мах.) размеров файлов задаётся пользователем в качестве первого и второго аргумента командной строки. На консоль выводится полный путь к файлу и его размер. Проверить работу программы для каталога /usr и диапазона (мин.- мах.) 1000 1010.

Запуск: ./program 1000 1010 /usr/include


lab_2: Отсортировать в заданном каталоге (аргумент 1 командной строки) и во всех его подкаталогах файлы по следующим критериям (аргумент 2 командной строки, задаётся в виде целого числа):1 – по размеру файла, 2 – по имени файла. Записать отсортированные файлы в новый каталог (аргумент 3 командной строки). Процедуры копирования должны запускаться в отдельном процессе для каждого копируемого файла с использованием функций read() и write(). Каждый процесс выводит на экран свой pid, полный путь, имя копируемого файла и число скопированных байт (все в одной строке). Число запущенных процессов в любой момент времени не должно превышать N (вводится пользователем).

Запуск: ./program /usr/include/boost /home/niko/forlder 1
Должно быть 2 программы (program, program_2). Тогда я не знал про fork();


lab_3: Создать дерево процессов согласно варианта индивидуального задания.
Процессы непрерывно обмениваются сигналами согласно табл. 2 .Запись в таблице 1 вида: 1->(2,3,4,5) означает, что исходный процесс 0 создаёт дочерний процесс 1, который, в свою очередь, создаёт дочерние процессы 2,3,4,5. Запись в таблице 2 вида: 1->(2,3,4) SIGUSR1 означает, что процесс 1 посылает дочерним процессам 2,3,4 одновременно (т.е. за один вызов kill() ) сигнал SIGUSR1.Каждый процесс при получении или посылке сигнала выводит на консоль информацию в следующем виде: N pid ppid послал/получил USR1/USR2 текущее время (мксек) где N-номер сына по табл. 1 После передачи 101–го по счету сигнала SIGUSR родительский процесс посылает сыновьям сигнал SIGTERM и ожидает завершения всех сыновей, после чего завершается. Сыновья, получив сигнал SIGTERM, завершают работу с выводом на консоль сообщения.

Запуск: лучше вообще не запускать, потому что собрать этот говнокод даже я с первого раза не смог. Да и вообще они тут как показатель откровенного говнокода. Но собрать можно. должно быть 9 программ. Код для первой программы отичается от кода остальных восьми. В восьми программах, используется предпроцессинг чтобы изменять выходной код. Это все собиралось правильно всего 1 раз. Тогда я не знал про fork();


lab_4: Создать два дочерних процесса. Родительский процесс создает семафор (сем1) и 2 неименованных канала (кан1 и кан2). Оба дочерних процесса непрерывно записывают в каналы по 110 строк вида: номер_строки pid_процесса текущее время (мксек). Родительский процесс читает из каждого канала по 75 строк и выводит их на экран. Всего дочерние процессы должны записать по 1010 строк. Семафор (сем1) используется процессами для разрешения кому из процессов получить доступ к каналу. Дочерние процессы начинают работу после получения сигнала SIGUSR2 от родительского процесса. По завершению работы они посылают сигнал SIGUSR1 родительскому процессу.

Запуск: ./program


lab_5: Два дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через один и тот же сегмент разделяемой памяти родительскому процессу очередные четыре строки некоторого стихотворения, при этом первый процесс передает нечетные четырехстишья, второй - четные. Циклы работ процессов не сбалансированы по времени. Родительский процесс компонует из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы обоих процессов. Решить задачу с использованием аппарата семафоров.

Запуск: ./program


lab_6: Создание GUI для приложения из лабораторной работы 5
Графическую часть буду делать с помощью GNOME GTK. Из-за того что он ругается на созданные процессы с помощью функции fork(), облегчу задачу, но вывод будет тот же.

Запуск: ./program


lab_7: Организовать взаимодействие типа клиент - сервер. Клиент делает запрос серверу на выполнение какой-либо команды. Сервер выполняет эту команду и возвращает результаты клиенту.

Запуск сервер: ./server
Запуск клиент: ./client [command]       
    Example: ./client ls -l


kurs - курсовая. Простейший windows сервер. Проверял только на linux mint 19-20.
